diff -c -r apache_1.1.3-orig/src/Configuration apache_1.1.3/src/Configuration
*** apache_1.1.3-orig/src/Configuration	Mon Jan 13 20:17:38 1997
--- apache_1.1.3/src/Configuration	Wed Feb 19 13:40:02 1997
***************
*** 84,89 ****
--- 84,91 ----
  # For Solaris 2.
  #AUX_CFLAGS= -DSOLARIS2
  #AUX_LIBS= -lsocket -lnsl
+ # Leave above commented and uncomment this one for mod_auth_dce support
+ #AUX_LIBS= -ldce -lthread -lsocket -lnsl -lm
  # For SGI IRIX. Use the AUX_LIBS line if you're using NIS and want
  # user-supported directories
  #AUX_CFLAGS= -DIRIX
***************
*** 96,101 ****
--- 98,105 ----
  #AUX_CFLAGS= -DULTRIX
  # For DEC OSF/1
  #AUX_CFLAGS= -DOSF1
+ # Uncomment for mod_auth_dce support (Digital DCE 2.x)
+ #AUX_LIBS= -ldce -lm
  # For NeXT
  #AUX_CFLAGS= -DNEXT
  # For Sequent
***************
*** 175,180 ****
--- 179,185 ----
  Module mime_module         mod_mime.o
  Module access_module       mod_access.o
  Module auth_module         mod_auth.o
+ Module auth_dce_module     mod_auth_dce.o
  Module negotiation_module  mod_negotiation.o
  Module includes_module     mod_include.o
  Module dir_module          mod_dir.o
diff -c -r apache_1.1.3-orig/src/http_request.c apache_1.1.3/src/http_request.c
*** apache_1.1.3-orig/src/http_request.c	Mon Jan 13 20:10:39 1997
--- apache_1.1.3/src/http_request.c	Wed Feb 19 13:22:08 1997
***************
*** 179,184 ****
--- 179,193 ----
  	    *cp = '\0';
  	    return OK;
  	}
+         /* Modification for mod_auth_dce -- This check is made before
+          * authentication modules are called. If the error is access
+          * denied, it is possible that once DCE credentials are obtained
+          * that the entry would be accessible. Therefore, return OK now,
+          * and mod_auth_dce will call this function again after credentials
+          * are obtained.
+          */
+         else if (errno == EACCES)
+           return OK;
  #if defined(ENOENT) && defined(ENOTDIR)
  	else if (errno == ENOENT || errno == ENOTDIR) {
  #else
diff -c -r apache_1.1.3-orig/src/md5.h apache_1.1.3/src/md5.h
*** apache_1.1.3-orig/src/md5.h	Thu Feb 22 03:46:52 1996
--- apache_1.1.3/src/md5.h	Wed Feb 19 13:22:09 1997
***************
*** 91,99 ****
    UINT4 state[4];                                   /* state (ABCD) */
    UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
    unsigned char buffer[64];                         /* input buffer */
! } MD5_CTX;
  
! extern void MD5Init(MD5_CTX *context);
! extern void MD5Update(MD5_CTX *context, const unsigned char *input,
  		      unsigned int inputLen);
! extern void MD5Final(unsigned char digest[16], MD5_CTX *context);
--- 91,99 ----
    UINT4 state[4];                                   /* state (ABCD) */
    UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
    unsigned char buffer[64];                         /* input buffer */
! } APACHE_MD5_CTX;
  
! extern void apache_MD5Init(APACHE_MD5_CTX *context);
! extern void apache_MD5Update(APACHE_MD5_CTX *context, const unsigned char *input,
  		      unsigned int inputLen);
! extern void apache_MD5Final(unsigned char digest[16], APACHE_MD5_CTX *context);
diff -c -r apache_1.1.3-orig/src/md5c.c apache_1.1.3/src/md5c.c
*** apache_1.1.3-orig/src/md5c.c	Thu Feb 22 03:46:52 1996
--- apache_1.1.3/src/md5c.c	Wed Feb 19 13:22:09 1997
***************
*** 158,164 ****
  /* MD5 initialization. Begins an MD5 operation, writing a new context.
   */
  void
! MD5Init(MD5_CTX *context)
  {
      context->count[0] = context->count[1] = 0;
    /* Load magic initialization constants. */
--- 158,164 ----
  /* MD5 initialization. Begins an MD5 operation, writing a new context.
   */
  void
! apache_MD5Init(APACHE_MD5_CTX *context)
  {
      context->count[0] = context->count[1] = 0;
    /* Load magic initialization constants. */
***************
*** 173,179 ****
    context.
   */
  void
! MD5Update(MD5_CTX *context, const unsigned char *input, unsigned int inputLen)
  {
      unsigned int i, index, partLen;
  
--- 173,179 ----
    context.
   */
  void
! apache_MD5Update(APACHE_MD5_CTX *context, const unsigned char *input, unsigned int inputLen)
  {
      unsigned int i, index, partLen;
  
***************
*** 209,215 ****
    the message digest and zeroizing the context.
   */
  void
! MD5Final(unsigned char digest[16], MD5_CTX *context)
  {
      unsigned char bits[8];
      unsigned int index, padLen;
--- 209,215 ----
    the message digest and zeroizing the context.
   */
  void
! apache_MD5Final(unsigned char digest[16], APACHE_MD5_CTX *context)
  {
      unsigned char bits[8];
      unsigned int index, padLen;
***************
*** 220,229 ****
    /* Pad out to 56 mod 64. */
      index = (unsigned int)((context->count[0] >> 3) & 0x3f);
      padLen = (index < 56) ? (56 - index) : (120 - index);
!     MD5Update(context, PADDING, padLen);
  
    /* Append length (before padding) */
!     MD5Update(context, bits, 8);
  
    /* Store state in digest */
      Encode(digest, context->state, 16);
--- 220,229 ----
    /* Pad out to 56 mod 64. */
      index = (unsigned int)((context->count[0] >> 3) & 0x3f);
      padLen = (index < 56) ? (56 - index) : (120 - index);
!     apache_MD5Update(context, PADDING, padLen);
  
    /* Append length (before padding) */
!     apache_MD5Update(context, bits, 8);
  
    /* Store state in digest */
      Encode(digest, context->state, 16);
diff -c -r apache_1.1.3-orig/src/mod_cgi.c apache_1.1.3/src/mod_cgi.c
*** apache_1.1.3-orig/src/mod_cgi.c	Mon Jun 17 13:43:47 1996
--- apache_1.1.3/src/mod_cgi.c	Wed Feb 19 13:22:12 1997
***************
*** 238,246 ****
          log_reason("script not found or unable to stat", r->filename, r);
  	return NOT_FOUND;
      }
!     if(!can_exec(&r->finfo)) {
          log_reason("file permissions deny server execution", r->filename, r);
          return FORBIDDEN;
      }
      if ((r->method_number == M_POST || r->method_number == M_PUT)
  	&& !lenp) {
--- 238,258 ----
          log_reason("script not found or unable to stat", r->filename, r);
  	return NOT_FOUND;
      }
!     /* Modification for mod_auth_dce -- This used to be a call to can_exec
!      * in util.c; however, that function does a naive bit check to decide
!      * if a script is executable. That fails in an environment with ACLs,
!      * where the server may have permission based on the ACL, but not on
!      * the Unix mode bits. The access() system call takes ACLs into account.
!      */
!     if(access(r->filename, X_OK)) {
!       if (errno == EACCES) {
          log_reason("file permissions deny server execution", r->filename, r);
          return FORBIDDEN;
+       }
+       else {
+         log_reason("system error checking execute access", r->filename, r);
+         return SERVER_ERROR;
+       }
      }
      if ((r->method_number == M_POST || r->method_number == M_PUT)
  	&& !lenp) {
diff -c -r apache_1.1.3-orig/src/mod_proxy.c apache_1.1.3/src/mod_proxy.c
*** apache_1.1.3-orig/src/mod_proxy.c	Wed Jul  3 08:02:58 1996
--- apache_1.1.3/src/mod_proxy.c	Wed Feb 19 13:22:16 1997
***************
*** 1007,1013 ****
  static void
  hash(const char *it, char *val,int ndepth,int nlength)
  {
!     MD5_CTX context;
      unsigned char digest[16];
      char tmp[22];
      int i, k, d;
--- 1007,1013 ----
  static void
  hash(const char *it, char *val,int ndepth,int nlength)
  {
!     APACHE_MD5_CTX context;
      unsigned char digest[16];
      char tmp[22];
      int i, k, d;
***************
*** 1015,1023 ****
      static const char table[64]=
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@";
  
!     MD5Init(&context);
!     MD5Update(&context, (const unsigned char *)it, strlen(it));
!     MD5Final(digest, &context);
  
  /* encode 128 bits as 22 characters, using a modified uuencoding */
  /* the encoding is 3 bytes -> 4 characters
--- 1015,1023 ----
      static const char table[64]=
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@";
  
!     apache_MD5Init(&context);
!     apache_MD5Update(&context, (const unsigned char *)it, strlen(it));
!     apache_MD5Final(digest, &context);
  
  /* encode 128 bits as 22 characters, using a modified uuencoding */
  /* the encoding is 3 bytes -> 4 characters
diff -c -r apache_1.1.3-orig/src/util_md5.c apache_1.1.3/src/util_md5.c
*** apache_1.1.3-orig/src/util_md5.c	Tue Mar 26 11:05:24 1996
--- apache_1.1.3/src/util_md5.c	Wed Feb 19 13:22:18 1997
***************
*** 85,91 ****
  
  char *md5 (pool *p, unsigned char *string)
  {
!     MD5_CTX my_md5;
      unsigned char hash[16];
      char *r, result[33];
      int i;
--- 85,91 ----
  
  char *md5 (pool *p, unsigned char *string)
  {
!     APACHE_MD5_CTX my_md5;
      unsigned char hash[16];
      char *r, result[33];
      int i;
***************
*** 94,102 ****
       * Take the MD5 hash of the string argument.
       */
  
!     MD5Init(&my_md5);
!     MD5Update(&my_md5, string, strlen((const char *)string));
!     MD5Final(hash, &my_md5);
  
      for (i=0, r=result; i<16; i++, r+=2)
          sprintf(r, "%02x", hash[i]);
--- 94,102 ----
       * Take the MD5 hash of the string argument.
       */
  
!     apache_MD5Init(&my_md5);
!     apache_MD5Update(&my_md5, string, strlen((const char *)string));
!     apache_MD5Final(hash, &my_md5);
  
      for (i=0, r=result; i<16; i++, r+=2)
          sprintf(r, "%02x", hash[i]);
***************
*** 150,156 ****
  static char basis_64[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
! char *md5contextTo64(pool *a, MD5_CTX *context)
  {
      unsigned char digest[18];
      char *encodedDigest;
--- 150,156 ----
  static char basis_64[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
! char *md5contextTo64(pool *a, APACHE_MD5_CTX *context)
  {
      unsigned char digest[18];
      char *encodedDigest;
***************
*** 159,165 ****
  
      encodedDigest = (char *)pcalloc(a, 25 * sizeof(char));
  
!     MD5Final(digest, context);
      digest[sizeof(digest)-1] = digest[sizeof(digest)-2] = 0;
  
      p = encodedDigest;
--- 159,165 ----
  
      encodedDigest = (char *)pcalloc(a, 25 * sizeof(char));
  
!     apache_MD5Final(digest, context);
      digest[sizeof(digest)-1] = digest[sizeof(digest)-2] = 0;
  
      p = encodedDigest;
***************
*** 177,191 ****
  
  char *md5digest(pool *p, FILE *infile)
  {
!     MD5_CTX context;
      unsigned char buf[1000];
      long length = 0;
      int nbytes;
  
!     MD5Init(&context);
      while ((nbytes = fread(buf, 1, sizeof(buf), infile))) {
          length += nbytes;
!         MD5Update(&context, buf, nbytes);
      }
      rewind(infile);
      return md5contextTo64(p, &context);
--- 177,191 ----
  
  char *md5digest(pool *p, FILE *infile)
  {
!     APACHE_MD5_CTX context;
      unsigned char buf[1000];
      long length = 0;
      int nbytes;
  
!     apache_MD5Init(&context);
      while ((nbytes = fread(buf, 1, sizeof(buf), infile))) {
          length += nbytes;
!         apache_MD5Update(&context, buf, nbytes);
      }
      rewind(infile);
      return md5contextTo64(p, &context);
diff -c -r apache_1.1.3-orig/src/util_md5.h apache_1.1.3/src/util_md5.h
*** apache_1.1.3-orig/src/util_md5.h	Wed Mar 20 19:50:16 1996
--- apache_1.1.3/src/util_md5.h	Wed Feb 19 13:22:19 1997
***************
*** 54,59 ****
  #include "md5.h"
  
  char *md5(pool *a, unsigned char *string);
! char *md5contextTo64(pool *p, MD5_CTX *context);
  char *md5digest(pool *p, FILE *infile);
  
--- 54,59 ----
  #include "md5.h"
  
  char *md5(pool *a, unsigned char *string);
! char *md5contextTo64(pool *p, APACHE_MD5_CTX *context);
  char *md5digest(pool *p, FILE *infile);
  
diff -c -r apache_1.1.3-orig/src/mod_userdir.c apache_1.1.3/src/mod_userdir.c
*** apache_1.1.3-orig/src/mod_userdir.c	Thu Mar 21 17:05:23 1996
--- apache_1.1.3/src/mod_userdir.c	Tue Apr  1 17:16:48 1997
***************
*** 115,120 ****
--- 115,126 ----
      char *name = r->uri;
      char *w, *dname, *redirect;
      char *x = NULL;
+     /* Modification for mod_auth_dce -- This module previously used the
+      * r->finfo structure for temporary storage of a local stat. This
+      * contaminated that structure and had unexpected side effects. Adding
+      * a local stat structure will fix the problem.
+      */
+     struct stat statbuf;
  
      if (userdirs == NULL || !strcasecmp(userdirs, "disabled") ||
          (name[0] != '/') || (name[1] != '~')) {
***************
*** 178,184 ****
         in the hope that some handler might handle it. This can be used, for
         example, to run a CGI script for the user. 
         */
!       if (filename && (!*userdirs || stat(filename, &r->finfo) != -1)) {
  	r->filename = pstrcat(r->pool, filename, dname, NULL);
  	return OK;
        }
--- 184,190 ----
         in the hope that some handler might handle it. This can be used, for
         example, to run a CGI script for the user. 
         */
!       if (filename && (!*userdirs || stat(filename, &statbuf) != -1)) {
  	r->filename = pstrcat(r->pool, filename, dname, NULL);
  	return OK;
        }
